#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct mp_pool {
    /** mp_pool.block_size is the size of each memory block. */
    size_t block_size;
    /** mp_pool.blockc is the number of blocks in the pool. */
    size_t blockc;
    /** mp_pool.blockc_in_use is the number of block currently in use. */
    size_t blockc_in_use;
    /** mp_pool.next_free is the index of the next free element.
     ** The header of each free blocks contains the adress of the next free block.
     ** All together it's a singly linked list. */
    size_t next_free;
    /** mp_pool.blocks is the actual memory pool.
     ** A block starts with a header of size sizeof(uint64_t).
     ** This header holds the index of the next free block. */
    uint8_t* blocks;
};

/** handle memory layout:
 ** A handle is a uint64_t.
 ** The first bit is not used.
 ** The following 31 bits are a control number generated by mp_alloc.
 ** The last 32 bits are the actual index of the block. */
static const uint64_t mp_mask_alive = 0x7FFFFFFF00000000;
static const uint64_t mp_mask_index = 0x00000000FFFFFFFF;

/** header memory layout:
 ** header is a uint64_t.
 ** The first bit tells if the memory has been initialized.
 ** The following 31 bits are a control number generated by mp_alloc.
 ** A block is alive if this number is non null.
 ** This number is tested against the one held in the handle.
 ** The last 32 bits are the index of the next free element in the pool.
 **   (valid only when the first 32 bits are set to 0). */
static const size_t mp_header_size = sizeof(uint64_t);
static const uint64_t mp_mask_init = 0x8000000000000000;

/** mp_block_size is the total size of a block in this pool. */
#define mp_block_size(pool) ((size_t)(pool->block_size + mp_header_size))

/** mp_header_ptr is the address of the header of the block at index. */
#define mp_header_ptr(pool, index) \
    ((uint64_t*)(pool->blocks + (index) * mp_block_size(pool)))

/** mp_header_ptr is the address of the payload of the block at index. */
#define mp_payload_ptr(pool, index) \
    ((void*)(pool->blocks + (index) * mp_block_size(pool) + mp_header_size))

/** mp_is_alive tells if the handle points to a valid block.
 ** The first 32 bits of the handle and of the header are compared. */
static bool mp_is_alive(const struct mp_pool* pool, uint64_t handle) {
    size_t index = handle & mp_mask_index;
    uint64_t alive = handle & mp_mask_alive;
    return pool->blockc > index
        && alive && alive == (*mp_header_ptr(pool,index) & mp_mask_alive);
}

/** mp_is_gettable tells if the handle points to a valid block and if it has been initialized. */
static bool mp_is_gettable(const struct mp_pool* pool, uint64_t handle) {
    size_t index = handle & mp_mask_index;
    return mp_is_alive(pool, handle)
        && (*mp_header_ptr(pool,index) & mp_mask_init);
}

/** mp_print_handle is used for debugging purpose. */
void mp_print_handle(uint64_t handle) {
    uint32_t index = handle & mp_mask_index;
    uint32_t alive = (handle & mp_mask_alive) >> 32;
    fprintf(stdout, "handle{index = %d ; alive = %x}\n", index, alive);
}

struct mp_pool* mp_pool_alloc(size_t blockc, size_t block_size) {
    assert(blockc > 0);
    assert(block_size > 0);
    struct mp_pool* pool = malloc(sizeof(struct mp_pool));
    assert(pool);
    pool->next_free = 0;
    pool->blockc_in_use = 0;
    pool->block_size = block_size;
    pool->blockc = blockc;
    pool->blocks = malloc(blockc * mp_block_size(pool));
    assert(pool->blocks);
    /* Fill the next_free list. */
    for (size_t b = 0; b < blockc; b++) {
        *(mp_header_ptr(pool, b)) = (uint64_t)((b+1) % pool->blockc);
    }
    return pool;
}

void mp_pool_free(struct mp_pool** pool) {
    if (!pool) {
        return;
    }
    free((*pool)->blocks);
    free(*pool);
    *pool = NULL;
}

bool mp_pool_is_empty(struct mp_pool* pool) {
    return pool && pool->blockc_in_use == 0;
}

bool mp_pool_is_full(struct mp_pool* pool) {
    return pool && pool->blockc_in_use == pool->blockc;
}

static uint32_t mp_uniq(void) {
    static uint32_t last = 0;
    last = (last+1) & (mp_mask_alive >> 32);
    return (last) ? last : 1;
}

bool mp_alloc(struct mp_pool* pool, uint64_t* handle) {
    if (!pool || !handle) {
        return false;
    }
    if (mp_pool_is_full(pool)) {
        return false;
    }
    size_t index = pool->next_free;
    pool->next_free = *(mp_header_ptr(pool, index)) & mp_mask_index;
    *handle = ((uint64_t)mp_uniq() << 32) + (uint64_t)index;
    *(mp_header_ptr(pool, index)) = *handle;
    pool->blockc_in_use++;
    return true;
}

bool mp_free(struct mp_pool* pool, uint64_t handle) {
    if (!pool) {
        return false;
    }
    if (mp_pool_is_empty(pool)) {
        return false;
    }
    if (!mp_is_alive(pool, handle)) {
        return false;
    }
    size_t index = handle & mp_mask_index;
    *(mp_header_ptr(pool, index)) = (uint64_t)pool->next_free;
    pool->next_free = index;
    pool->blockc_in_use--;
    return true;
}

const void* mp_get(struct mp_pool* pool, uint64_t handle) {
    if (!pool) {
        return NULL;
    }
    if (!mp_is_gettable(pool, handle)) {
        return NULL;
    }
    size_t index = handle & mp_mask_index;
    return mp_payload_ptr(pool, index);
}

bool mp_put(struct mp_pool* pool, uint64_t handle, const void* block) {
    if (!pool) {
        return false;
    }
    if (!mp_is_alive(pool, handle)) {
        return false;
    }
    size_t index = handle & mp_mask_index;
    *mp_header_ptr(pool, index) |= mp_mask_init; // Set init bit.
    memcpy(mp_payload_ptr(pool, index),
            block, pool->block_size);
    return true;
}
